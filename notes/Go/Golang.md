
Пакеты - это способы организации кода в Go. 
Пакеты должны быть узконаправленными и выполнять только одну задачу. Например, Аргументы, Графики, Обработка запросов HTTP - это все были бы разные пакеты
Пакеты через import
``` Go
import "name"
import (
	"name",
	"namespace/packageName"
)
```
По умолчанию надо ссылаться на имя пакета в коде. Если это не нужно, то можно использовать ".", тогда получим доступ ко всему
``` Go
import (
	. "name",
	pk "namespace/packageName"
)
```

Штуки используемые вместе с GO
CockroachDB
Dgraph


Типы данных:
Go является статически типизированным языком. 
Все примитивные типы данных являются числовыми (то есть под капотом байты), а типы указанные в коде - просто условность для разработчиков.

Целочисленные типы:

| Тип данных | Min значение         | Max значение        |
| ---------- | -------------------- | ------------------- |
| int8       | -128                 | 127                 |
| int16      | -32768               | 32767               |
| int        | -2147483648          | 2147483647          |
| int32      | -2147483648          | 2147483647          |
| int64      | -9223372036854775808 | 9223372036854775807 |

Беззнаковые типы, которые могут принимать только положительные значения:

| Тип данных | Min значение | Max значение         |
| ---------- | ------------ | -------------------- |
| uint8      | 0            | 255                  |
| byte       | 0            | 255                  |
| uint16     | 0            | 65535                |
| uint       | 0            | 4294967295           |
| uint32     | 0            | 4294967295           |
| uint64     | 0            | 18446744073709551615 |
| uintptr    | 0            | pointer size         |

Другие типы данных:

| Тип данных     | Описание                                                                 |
| -------------- | ------------------------------------------------------------------------ |
| float32        | 32-bit плавающая точка                                                   |
| float64        | 64-bit плавающая точка                                                   |
| complexes      | 32-bit вещественные и мнимые числа                                       |
| complexes bool | 64-bit вещественное и мнимое число с плавающей запятой, истинно или ложь |


Псевдонимы переменных:
В Go можно создавать псевдонимы для типов данных
Псевдонимы типов данных в Go идентичны по всем аспектам, за исключением имени.
Пример использование:
```Go
type UserId int
type Direction byte
type Speed float64
type Velocity Speed
```



Go использует UTF-8 для кодирования текстовых данных
Руны:
Текст представляется с помощью типа rune (аналог char)
Тип rune является просто псевдонимом для типа int32 (целое число 32-битной длины). Всегда выводится числовое значение руны, если не указаны соответствующее форматирование.
Тип rune представляет любой символ. Это могут быть цифры, буквы, эмодзи и т.д.


Строки:
Строка - это тип данных для хранения нескольких символов (runes)
Строки - это просто массив байтов и длина строки
В Go-строках нет нулевого завершения
При итерации по строке в Go итерация происходит по байтам. Байты не являются символами. 
![[attachments/Pasted image 20250705212455.png]]

Для символа надо использовать одинарную кавычку <'>. Если символ не на клавиатуре, то \`. Чтобы использовать экранирование \ - надо использовать двойные кавычки.
![[attachments/Pasted image 20250705212628.png]]

Команды Go. 

В Go используется специальная команда, которая выполняет большинство функций - "go".
Список команд:
"build" - компилирует проект и создает исполняемый бинарный файл.
	"build - race" проверяет наличие проблем с параллелизмом/конкурентностью
"run" - запускает проект напрямую, без создания исполняемого файла
"mod" - управляет модулями и зависимостями
	"mod tidy" - обновляет зависимости
"test" - запускает тестовый набор проекта
"fmt" - форматирует все файлы исходного кода 


Переменные
Переменные имеют несколько компонентов:
1 - Имя, 2 - Данные (или их отсутствие), 3 - Тип

Единственное значение:
```Go
var example = 3

var example int = 3

var example int 
example = 3
```
Комплексное создание:
```Go
var a, b, c = 1, 2, "sample"
```
Использование блоков:
```Go
var (
	a int = 1
	b int = 2
	c = "sample"
)
```
Создание и присваивание:
```Go
example := 3

a, b := 1, "sample"
```

При 
```Go
a := 1
b := a
c := b
a = 3
```
Переменная b и c будут равны 1, т.к. оператор присваивание берет просто значение копии, а не ссылку как в Питоне.

У переменных есть значение по умолчанию, если мы их создадим, но не дадим значение, например:
```Go
var name string
```
Строковое значение по умолчанию - ""
Числовое значение по умолчанию - 0
Другие элементы по умолчанию - nil

Создавать новые переменные с таким же названием нельзя, например:
```Go
a := 1
var a = 5
```
Этот фрагмент вызовет ошибку.

Оператор присваивания почему-то не дает ошибку при такой записи:
![[attachments/Pasted image 20250705214146.png]]

В Go используется camelCase
```Go
myLongVariableName := "hi"
```
Комментарии - //


Также есть константы. Каждое слово начинается с заглавной буквы. Для них не нужны определять тип данных. Пример:
```Go
const MaxSpeed = 30
const MinPurchasePrice = 150
const AppAuthor = "Bob"
```



Функции:
```Go
func name(param1 type, param2 type) type {
	// body
}
```
![[attachments/Pasted image 20250705215240.png]]

Логические операторы:

&& - И 
|| - ИЛИ
! - НЕ

Условия:

```Go
if condition {
	// todo something
}

if condition {
	// todo if true
} else {
	// todo if not true
}

if condition {
	// todo
} else if condition2 {
	// todo
} else {
	// todo
}
```

Инициализация оператора в условии:
```Go
if i := 5; i < 10 {
	// todo
} else {
	// todo
}

if rank := getUserRank("Zero"); rank == "admin" {
	// Access 
} else if rank == "manager" {
	// second access
} else {
	// no access
}
```

В Go тоже есть оператор match case. Работает сверху-вниз. Пример:

```Go
x := 3
switch x {
case 1:
	fmt.Println("1")
case 2:
	fmt.Println("2")
case 3:
	fmt.Println("3")
default:
	fmt.Println("other")
}
```

default отрабатывает, если ни один не сработал

Также есть условные варианты:
```Go
switch result := calculate(5); {
case result > 10:
	fmt.Println(">10")
case result == 6:
	fmt.Println("6")
case result < 10:
	fmt.Println("<10")
}
```
И еще есть списки вариантов:
```Go
switch x {
case 1, 2, 3:
	// ...
case 4, 5, 6:
	// ...
}
```
Есть возможность продолжить проверку, даже если упали в один из case'ов. Для этого нужно использовать ключевое слово `fallthrough`. Пример:
```Go
switch letter {
case ' ':
case 'a', 'e', 'i', 'o', 'u':
	fmt.Println("A vowel")
	fallthrough
case 'A', 'E', 'I', 'O', 'U':
	fmt.Println("Vowels are great!")
default:
	fmt.Println("It's something else")
}
```


Циклы:

Базовый цикл:
```Go
for i := 0; i < 10; i ++ {
	// ...
}
```
![[attachments/Pasted image 20250705221311.png]]
Цикл while (ВАЖНО: переменная должна быть создана заранее):
```Go
for i < 10 {
	i ++
}
```
Бесконечный цикл:
```Go
for {
	//...
}

// Для выхода из него
for {
	if somethingHappened {
		break
	}
}
```
Для пропуска текущей итерации можно использовать `continue`:
```Go
for i := 0; i < 10; i++ {
	 if i % 2 == 0 {
		 continue
	 }
	 fmt.Println(i)
}
```


Структуры (что-то типо классов):

```Go
type Sample struct {
	field string
	a, b int
}

// Создание 1
data := Sample{"word", 1, 2}

// Создание 2
data := Sample{
	field: "word",
	a: 1,
	b: 2,
}
```
Любые поля, которые не были обозначены при создании экземпляра, будут иметь значения по умолчанию.

Анонимные структуры:
```Go
// 1 Вариант - Полная версия
var sample struct {
	field string
	a, b int
}

sample.field = "hello"
sample.a = 1
sample.b = 2

// 2 Вариант - Сокращенная версия
sample := struct {
	field string
	a, b int
}{
	"hello",
	1, 2,
}
```


Массивы:
Массив используется для хранения нескольких элементов ОДНОГО типа. Массивы имеют фиксированный размер и их нельзя изменить.

Визуализация массива в памяти *[момент из видео](https://youtu.be/QrVHFGtCAnE?t=74)*:
![[attachments/Pasted image 20250705222527.png]]

Создание массива:
Квадратные скобки для размерности, а фигурные для значений. Размерность \[...] позволяет языку самому поставить размерность и является предпочтительным.

```Go
var myArray [3]int

myArray := [3]int{7, 8, 9}

myArray := [...]int{7, 8, 9}

myArray := [4]int{7, 8, 9}
```

Итерация по массиву:
```Go
myArray := [...]int{7, 8, 9}

for i := 0; i < len(myArray): i++ {
	item := myArray[i]
	fmt.Println(item)
}
```

Срезы:

Срезы объявляются как массивы, но не надо писать размерность. Т.е. квадратные скобки будут пустыми. Имеет вид \[a, b], где a - это начало (включительно), а b - это конец среза (не включительно):
```Go
mySlice := []int{1, 2, 3}

item1 := mySlice[0]


// Срез имеет вид -
slice[a:b]

//Примеры срезов
numbers := [...]int{1, 2, 3, 4}

slice1 := numbers[:] // [1, 2, 3, 4]

slice2 := numbers[1:] // [2, 3, 4]
slice3 := numbers[:1] // [2]

slice4 := numbers[:2] // [1, 2]

slice5 := numbers[1:3] // 2, 3
```

С помощью срезов можно создавать массивы, которые могут быть расширены.
Функция append() может добавлять дополнительные элементы 
```Go
numbers := []int{1, 2, 3}
numbers = append(numbers, 4, 5, 6)
// [1, 2, 3, 4, 5, 6]
```
Три точки могут быть использованы для расширения среза с помощью другого среза:
```Go
part1 := []int{1, 2, 3}
part2 := []int{4, 5, 6}
combined := append(part1, part2...)
```
Срезы также могут быть предварительно выделены с указанием определенной ёмкости. Функция make() используется для предварительного выделения памяти для среза
```Go
slice := make([]int, 10)
```
Параметры функций, которым требуется срез, могут работать со срезами любого размера:
```Go
func iterate(slice []int) {
	for i := 0; i < len(slice); i++ {
		// ...
	}
}
small := []int{1}
big := []int{1, 2, 3, 4, 5, 6, 7}
iterate(small)
iterate(big)
```

Многомерные срезы:
```Go
board := [][]string{
	// type declaration is optional
	[]string{"_", "_", "_"},
	{"_", "_", "_"},
	{"_", "_", "_"},
}
board[0][0] = "X"
board[2][2] = "O"
board[1][2] = "X"
board[1][0] = "O"
board[0][2] = "X"
```


Карты (Hashmaps, словарь)
Структура данных, хранящая пары ключ-значение. Неупорядоченный.

Создание:
```Go
myMap := make(map[string]int)
myMap := map[string]int{
	"item 1": 1,
	"item 2": 2,
	"item 3": 3,
}

// Insert
myMap["favorite number"] = 5

// Read
fav := myMap["favorite number"]
missing := myMap["age"] // default value

// Delete
delete(myMap, "favorite number")

// Check Existence
price, found := myMap["price"]
if !found {
	fmt.Println("price not found")
	return
}
```

Итерация по мапам:
```Go
myMap := make(map[string]int)

for key, value := range myMap {
	// ...
}
```


Указатели:

Вызовы функций в Go осуществляется по значению. Для каждого аргумента функции  создается копия, вне зависимости от её размера, потому вызов для больших структур данных может быть потенциально медленным, из-за чего становится сложно управлять состоянием программы.

Это можно исправить, используя указатели.
Указатели - это переменные, которые указывают на определенную область в памяти. Значение самой переменной представляет собой адрес памяти. Для доступа к данным необходимо выполнить разыменование указателя. Это позволяет изменять значения, которые существуют в других частях программы.

Создание указателей
Оператор разыменования или астериск (\*) вместе с типом указывает, что значение является указателем
Амперсанд (&) создает указатель на переменную

Создаем переменную value со значением 10.
Потом создаем переменную valuePtr (Ptr - это всегда сокращение pointer, т.е. указатель) и указываем \*int. Таким образом мы создали указатель на целое число integer. В переменной valuePtr будет адрес в памяти.

```Go
// Полная версия
value := 10

var valuePtr *int
valuePtr = &value
```
---------------------------------------
```Go
// Укороченная версия
value := 10
valuePtr := &value
```

Использование указателей:
Астериск (\*) при использовании с указателем будет разыменовывать указатель
Это предоставляет доступ к фактическим данным, на которые указывает указатель
```Go
func increment(x *int) {
	*x += 1
}

i := 1
increment(&i)
// i == 2
```
![[attachments/Pasted image 20250705230411.png]]


Методы:
Изменена сигнатура функции для поддержки синтаксиса точечной нотации
Делает написание некоторых типов функциональности более удобным
Позволяет простое изменение существующих структур.
	Метод в виде функции:

```Go
type Coordinate struct {
	X, Y int
}

func shiftBy(x, y int, coord *Coordinate) {
	coord.X += x
	coord.Y += y
}

coord := Coordinate{5, 5}
shiftBy(1, 1, &coord) // (6, 6)
```

	Метод (указатель), т.е. просто изменение изначальной структуры:
``` Go
type Coordinate struct {
	X, Y int
}

func (coord *Coordinate) shiftBy(x, y int) {
coord.X += x
coord.Y += y
}

coord := Coordinate{5, 5}
coord.shiftBy(1, 1) // (6, 6)
```

	Метод (значение), т.е. изменение структуры, используя переданное значение:
```Go
type Coordinate struct {
	X, Y int
}

func (c Coordinate) Dist(other Coordinate) Coordinate {
return Coordinate{c.X - other.X, c.Y - other.Y}
}

first := Coordinate{2, 2}
second := Coordinate{1, 5}
distance := first.Dist(second) // (-1, 3)
```
	