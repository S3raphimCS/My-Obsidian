==Сложность алгоритмов== - порядок количества действий, которые выполняет алгоритм. Выражается, как O большое от функции N, например O(n) означает, что алгоритм выполниться с количеством повторений равным количеству входных данных (также называют "верхняя оценка")

==100 * N = O(N), 2*N = O(N)==. 100 и 2 - константы, не зависящие от размера входных данных. Константы не так сильно влияют на скорость работы алгоритма при больших параметрах. 

Также бывает "==[[#Пространственная сложность]]==" - количество использованной памяти


## Пример:
	Дана строка (в кодировке UTF-8). Необходимо найти самый часто встречающийся в ней символ. Если несколько символов встречаются одинаково часто, то можно вывести любой.


Решение №1:
	Переберем все позиции и для каждой позиции в строке еще раз переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.
	
```python
s = input()
ans = ''
anscnt = 0
for i in range(len(s)):
	nowcnt = 0
	for j in range(len(s)):
		if s[i] == s[j]:
			nowcnt += 1
	if nowcnt > anscnt:
		ans = s[i]
		anscnt = nowcnt
print(ans)
```
	В данном случае сложность алгоритма равна O(N^2). Очевидно, не самое лучшее решение. По памяти нужно O(N), т.к. по большому счету мы храним только саму строку

Решение №2:
	Переберем все символы, встречающиеся в строке, а затем переберем все позиции и в случае совпадения прибавим к счетчику единицу. Найдем максимальное значение счетчика.
```python
s = input()
ans = ''
anscnt = 0
for now in set(s):
	nowcnt = 0
	for j in range(len(s)):
		if now == s[j]:
			nowcnt += 1
	if nowcnt > anscnt:
		ans = now
		anscnt = nowcnt
print(ans)
```
	Сложность алгоритма в этом случае будет - O(Nk). Мы дополнительно храним множество, которое занимает k, потому O(N + k) = O(N).

Решение №3:
	Заведем словарь, где ключом является символ, а значением - сколько раз он встретился. Если символ встретился впервые - создаем элемент словаря с ключом, совпадающем с этим символом и значением ноль. Прибавляем к элементу словаря с ключом, совпадающем с этим символом, единицу.
```python
s = input()
dct = {}
for now in s:
	if now not in dct:
		dct[now] = 0
	dct[now] += 1
print(max(dct, key=dct.get)
```
	Сложность алгоритма в этом случае будет - O(N). 


| Решение                                               | Время  | Память          |
| ----------------------------------------------------- | ------ | --------------- |
| #1 (Проход по строке для каждого символа в строке)    | O(N^2) | O(N)            |
| #2 (Проход по строке для каждого символа в множестве) | O(Nk)  | O(N + k) = O(N) |
| #3 (Использование словаря)                            | O(N)   | O(k)            |


График роста О большое:
![[Pasted image 20250324220840.png]]


Временные сложности знаменитых алгоритмов:

1. Поиск
![[Pasted image 20250324220924.png]]
2. Сортировка
![[Pasted image 20250324220940.png]]
3. Структуры данных
![[Pasted image 20250324220951.png]]
4. Кучи
![[Pasted image 20250324221001.png]]
5. Представление графов
Пусть дан граф с |V| вершинами и |E| ребрами, тогда
![[Pasted image 20250324221021.png]]

###### Также существует <u>два других термина</u>, когда говорят про алгоритмическую сложность - это нижняя оценка (омега) и усредненная оценка (тета):

1. Нижняя оценка (омега) - позволяет оценить нижнюю границу сложности. **f(n)=Ω(g(n))** означает, что **f(n)** будет расти не медленее, чем **g(n)**. ^5e773a
2. Усредненная оценка (тета) - позволяет получить точную оценку сложности. **f(n)=Θ(g(n))** означает, что функция **f(n)** ограничена функцией **g(n)** сверху и снизу. ^e4322a
3. В свою очередь, Верхняя оценка (О большое) - позволяет оценить верхнюю границу алгоритмов. **f(n)=O(g(n))** означает, что функция **f(n)** будет расти не быстрее, чем **g(n)**

Другое [определение](https://habr.com/ru/articles/188010/):
![[Pasted image 20250324221037.png]]
1. (О — большое) — верхняя граница, в то время как (Омега — большое) — нижняя граница. Тета требует как (О — большое), так и (Омега — большое), поэтому она является точной оценкой (она должна быть ограничена как сверху, так и снизу). К примеру, алгоритм требующий Ω (n logn) требует не менее n logn времени, но верхняя граница не известна. Алгоритм требующий Θ (n logn) предпочтительнее потому, что он требует не менее n logn (Ω (n logn)) и не более чем n logn (O(n logn)).
2. f(x)=Θ(g(n)) означает, что f растет так же как и g когда n стремится к бесконечности. Другими словами, скорость роста f(x) асимптотически пропорциональна скорости роста g(n).
3. f(x)=O(g(n)). Здесь темпы роста не быстрее, чем g (n). O большое является наиболее полезной, поскольку представляет наихудший случай.
![[Pasted image 20250324220814.png]]
![[Pasted image 20250324220336.png]]

## Пространственная сложность

Определяется потребляемой памятью. Для нахождения пространственной сложности фиксируется характер роста используемой памяти при увеличении размера входных данных. 
Входные данные обычно здесь не засчитываются. 
![[Pasted image 20250312190347.png]]
Память вычисляется оттого, насколько наши переменные растут в зависимости от <u>входных данных</u>. То есть, если есть переменные l, r, и max, которые хранят в себе одно число при любых входных данных, то сложность будет константой (O(1)), а если в начале кода создается дополнительная переменная, которая копирует основной список входных данных, то пространственная сложность будет O(n)
## Тестирование

Заключительный этап работы с алгоритмами это сдача задания, но перед этим необходимо протестировать решение. <u>Какие тесты сделать?</u> На примере задания нахождения максимума в последовательности:
1) Общий случай
   - 1 3 2
2) Пограничные случаи
   - 1 2 3
   - 3 2 1
3) Одинаковые значения (любой элемент является ответом)
   - 1 1 1
4) Всего один элемент	
   -  1
5) Пустая последовательность
   - 
6) Все отрицательные
   - -2 -1 -3

Советы по составлению тестов:
> 1) Если есть примеры, то необходимо решить все руками и сверить ответ.
> 2) Сначала составить несколько примеров и прорешать их руками, чтобы лучше понять условие и было с чем сравнить.
> 3) Проверить случаи, [описанные выше](#Тестирование).
> 4) Составить покрытие всех ветвлений, так чтобы был тест, которые входит в каждый if/else.
> 5) Сделать тест, чтобы не было ни одного входа.
> 6) Один тест - одна возможная ошибка

[Источник](https://youtu.be/QLhqYNsPIVo?t=871)
